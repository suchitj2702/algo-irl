rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Problems collection - read-only for clients
    match /problems/{problemId} {
      allow read: if true;
      allow write: if false; // Only backend can write
    }
    
    // Companies collection - read-only for clients (legacy)
    match /companies/{companyId} {
      allow read: if true;
      allow write: if false; // Only backend can write
    }

    // Companies v2 collection - read-only for clients (active)
    match /companies-v2/{companyId} {
      allow read: if true;
      allow write: if false; // Only backend can write
    }

    // Code submissions - no direct client access
    match /codeSubmissions/{submissionId} {
      allow read: if false;
      allow write: if false;
    }

    // Problem transformations cache - no direct client access (legacy)
    match /problemTransformations/{transformId} {
      allow read: if false;
      allow write: if false;
    }

    // Problem transformations v2 cache - no direct client access (active)
    match /problemTransformations-v2/{transformId} {
      allow read: if false;
      allow write: if false;
    }
    
    // Scenarios cache - no direct client access
    match /scenarios/{scenarioId} {
      allow read: if false;
      allow write: if false;
    }

    // Problem role scores - read-only for clients
    match /problemRoleScores/{problemId} {
      allow read: if true;
      allow write: if false; // Only backend can write
    }

    // Study plan cache - no direct client access
    match /studyPlanCache/{cacheKey} {
      allow read: if false;
      allow write: if false;
    }

    // User profiles - users can read/write their own, but cannot modify payment fields
    match /users/{uid} {
      allow read: if isOwner(uid);
      allow create: if isOwner(uid);
      allow update: if isOwner(uid)
        && !request.resource.data.diff(resource.data).affectedKeys()
             .hasAny(['razorpayCustomerId', 'tier', 'subscriptionStatus', 'subscriptionTier',
                      'subscriptionCurrentPeriodEnd', 'subscriptionCancelAt']);
      allow delete: if false; // Prevent accidental deletion

      match /preferences/{docId} {
        allow read: if isOwner(uid);
        allow write: if isOwner(uid);
      }
    }

    match /userStudyPlans/{uid}/plans/{planId} {
      allow read: if isOwner(uid);
      allow write: if isOwner(uid);
    }

    match /userStudyPlanProgress/{uid}/progress/{docId} {
      allow read: if isOwner(uid);
      allow write: if isOwner(uid);
    }

    match /customers/{uid} {
      allow read: if isOwner(uid);
      allow write: if false;

      match /subscriptions/{subscriptionId} {
        allow read: if isOwner(uid);
        allow write: if false;
      }

      match /payments/{paymentId} {
        allow read: if isOwner(uid);
        allow write: if false;
      }
    }

    // Block all other collections by default
    match /{document=**} {
      allow read: if false;
      allow write: if false;
    }
  }

  function isOwner(uid) {
    return request.auth != null && request.auth.uid == uid;
  }

  // Helper function to check if user has active premium subscription
  function hasActiveSubscription(uid) {
    let user = get(/databases/$(database)/documents/users/$(uid));
    return user.data.tier == 'premium';
  }
}

// Additional security considerations for Firestore:
// 1. Enable App Check to prevent unauthorized API access
// 2. Set up monitoring and alerting for unusual patterns
// 3. Implement collection-level quotas in Firebase console
// 4. Regular backups of critical data
